<html>
    <body>
<!-- Crop the image of the tileset to the tile ; used with object-position below -->
<style>
img {
    object-fit:none;
}
#map div.layer {
    position:absolute;
    top:0;
    left:0;
}
img.flippedX {
    transform: scaleX(-1);
}
img.flippedY {
    transform: scaleY(-1);
}
img.flippedXY {
    transform: scale(-1,-1);
}
</style>
        <div id="map" style="position:relative"></div>
        <script>
        function drawLayer (id, width, height, tileSizeX, tileSizeY, layerContent, tilesetWidth, tilesetHeight, firstGid) {
            let map = document.getElementById ("map");
            const mapXSize = width * tileSizeX;
            const mapYSize = height * tileSizeY;
            var cellIndex = 0;
            var layerDiv = document.createElement ("div");
            for (var y = 0; y < mapYSize; y += tileSizeY) {
                var lineDiv = document.createElement ("div");
                for (var x = 0; x < mapXSize; x += tileSizeX) {
                    // The tile ids start at firstGid and increment over every tile in the tileset
                    var tileId = layerContent [cellIndex] - firstGid;
                    const flipFlags = tileId & 0xF0000000;
                    tileId = tileId & 0xFFFFFFF;   // Remove the rotation bits from the tile id
                    var cellImg = document.createElement ("img");
                    // We show only one tile from the tileset
                    cellImg.setAttribute ("width", tileSizeX + "px");
                    cellImg.setAttribute ("height", tileSizeY + "px");
                    // Use the Tiled exported tileset as the source for the image
                    cellImg.setAttribute ("src", "tileset.png");
                    // Draw the tile appropriately to the rotation
                    if (flipFlags !== 0) {
                        var flipClass = "";
                        if (flipFlags & 0x80000000) {
                            flipClass += "flippedX ";
                        }
                        // NOTE : not tested
                        if (flipFlags & 0x40000000) {
                            flipClass += "flippedY ";
                        }
                        // NOTE : not tested
                        if (flipFlags & 0x20000000) {
                            flipClass += "flippedXY ";
                        }
                        cellImg.setAttribute ("class", flipClass);
                    }
                    if (tileId >= 0) {
                        // Offset the tileset image so that the part that is visible is the tile which ID we know
                        const yOffset = tileSizeY * (tileId / tilesetWidth | 0);
                        const xOffset = tileSizeX * (tileId % tilesetWidth);
                        cellImg.setAttribute ("style", "object-position:-" + xOffset + "px -" + yOffset + "px");
                    }
                    else {
                        // Offset the tilset image so that it is not visible (making the tile transparent)
                        cellImg.setAttribute ("style", "object-position:" + tileSizeX + "px " + tileSizeY + "px");
                    }
                    lineDiv.appendChild (cellImg);
                    cellIndex ++;
                }
                layerDiv.appendChild (lineDiv);
            }
            layerDiv.setAttribute ("id", id);
            layerDiv.setAttribute ("class", "layer");
            map.appendChild (layerDiv);
        }
        </script>
        <!-- Load the js library used for unzipping the layer -->
        <!-- You can get pako.js from https://raw.githubusercontent.com/nodeca/pako/master/dist/pako.js -->
        <script type="text/javascript" src="pako.js"></script>
        <!-- Load the Tiled map -->
        <script type="text/javascript" src="map.js"></script>
        <!-- Show the layers of the map, using the first tileset -->
        <script>
            var tileMap;
            for (var mapName in TileMaps) {
                tileMap = TileMaps [mapName];
            }

            for (var layer of tileMap.layers) {
                if (layer.type !== "tilelayer") {
                    continue;
                }
                // Retrieve the layer data by unzipping the layer data
                const layerHeight = layer.height;
                const layerWidth = layer.width;
                // Unzipping the layer data :
                // Decode base64 (convert ascii to binary)..
                const strData     = atob(layer.data);
                // Convert binary string to character-number array..
                const charData    = strData.split('').map(function(x){return x.charCodeAt(0);});
                // Turn number array into byte-array..
                const binData     = new Uint8Array(charData);
                // Unzip..
                const data        = pako.inflate(binData);
                // ..and turn into an array of 32 bytes unsigned integers, containing the tile ids. 
                var layerContent = new Uint32Array(data.buffer);

                // Retrieve tileset size and first tile id
                const tileSet = tileMap.tilesets [0];
                const firstGID = tileSet.firstgid;
                const tilesetWidth = tileSet.imagewidth / tileSet.tilewidth;
                const tilesetHeight = tileSet.imageheight / tileSet.tileheight;

                drawLayer ("layer " + layer.id, layerWidth, layerHeight, tileSet.tilewidth, tileSet.tileheight, layerContent, tilesetWidth, tilesetHeight, firstGID);
            }
        </script>
    </body>
</html>

